import condacmds as cmds
from condacmds import download_pyme_extra, download_pyme, build_pyme_extra, build_pyme, build_pyme_meson, pyme_extra_install_plugins, download_pyme_extra_release, download_pyme_release
from pathlib import Path
import logging

# from here we get all the relevant package settings to build the environment
from packagesettings import Packages, Pymex_conda_packages, Pymex_pip_packages

# 0. some basic setup/parameter choices via command line arguments

import sys
commandline = " ".join(sys.argv)

import argparse
parser = argparse.ArgumentParser()
parser.add_argument('--python',default='3.10',
                    help='specify the python version for the new environment')
parser.add_argument('--buildstem',default='build-test',
                    help='stem for the name of the build directory')
parser.add_argument('--suffix',default=None,
                    help='suffix appended to default environment and build_dir')
parser.add_argument('-c','--condacmd',default='conda',choices=['conda','mamba'],
                    help='conda command, should be one of conda or mamba')
parser.add_argument('-e','--environment',default=None,
                    help='name for the new environment, autogenerated from other params by default')
parser.add_argument('--recipes',action="store_true",
                    help='install the included customrecipes into the PYME config directory')
parser.add_argument('--pyme-repo',default='python-microscopy/python-microscopy',
                    help='github repository name of python-microscopy; defaults to python-microscopy/python-microscopy')
parser.add_argument('--pyme-branch',default='master',
                    help='branch of pyme to use in build; defaults to master')
parser.add_argument('--pymex-repo',default='csoeller/PYME-extra',
                    help='github repository name of PYME-extra; defaults to csoeller/PYME-extra')
parser.add_argument('--pymex-branch',default='master',
                    help='branch of PYME-extra to use in build; defaults to master')
parser.add_argument('--no-pymex',action="store_true",
                    help='omit downloading and installing PYME-extra')
parser.add_argument('--no-pyme-build',action="store_true",
                    help='omit building and installing PYME')
parser.add_argument('--no-pyme-depends',action="store_true",
                    help='install from package list rather than using pyme-depends')
parser.add_argument('--pyme-release',default=None,
                    help='release tag for PYME release to build; mutually exclusive with --use-git option')
parser.add_argument('--pymex-release',default=None,
                    help='release tag for PYME-extra release to build; mutually exclusive with --use-git option')
parser.add_argument('--use-git',action="store_true",
                    help='clone git repo locally rather than just downloading snapshot')
parser.add_argument('--no-strict-channel',action="store_true",
                    help='enforce strict adherance to conda-forge channel')
parser.add_argument('--dry-run',action="store_true",
                    help='just process options but do not run any commands')
parser.add_argument('-x','--xtra-packages', action="extend", nargs="+", type=str,
                    help='extra packages to install into the new environment')
parser.add_argument('--matplotlib-numpy-latest',action="store_true",
                    help='instruct conda to use latest matplolib and numpy; currently used for testing of numpy>=2 and PYME meson build')
parser.add_argument('--setuptools-latest',action="store_true",
                    help='instruct conda to use latest setuptools; currently used for testing PYME meson build')
parser.add_argument('--pyme-build-meson',action="store_true",
                    help='build pyme with meson (new build method)')



### Note
### we may want to add, will enforce from conda-forge over default channel (I think)
# conda config --set channel_priority strict
# we should be able to provide this as an option, according to https://docs.conda.io/projects/conda/en/latest/commands/install.html:
#  --strict-channel-priority
### Check how to check, verify and unset


# other possible arguments to enable
# --pyme-branch: pick a branch other than the default 'master' branch
# --pyme-extra-branch: pick a branch other than the default 'master' branch
# --build_dir: specify full build directory name (e.g. for a more permanent install)
# potentially add jupyter notebook option
# potentially add R option (+R notebooks?)
# potentially allow cloning the whole github repos with a command line switch

args = parser.parse_args()

cmds.check_condaenv('base') # check we are running in the base environment
cmds.check_yaml_installed() # check yaml is available


# # this makes methods/attributes for the standard parameters available
# # also does any setup stuff, e.g. create build_dir, setup logging etc
pbld = cmds.PymeBuild(pythonver=args.python,
                      build_dir=args.buildstem,
                      condacmd=args.condacmd,
                      environment=args.environment,
                      with_pyme_depends=not args.no_pyme_depends,
                      with_pyme_build=not args.no_pyme_build,
                      with_pymex=not args.no_pymex,
                      with_recipes=args.recipes,
                      pyme_repo=args.pyme_repo, pyme_branch=args.pyme_branch,
                      pymex_repo=args.pymex_repo, pymex_branch=args.pymex_branch,
                      use_git=args.use_git,suffix=args.suffix,
                      strict_conda_forge_channel=not args.no_strict_channel,
                      dry_run=args.dry_run,xtra_packages=args.xtra_packages,
                      pyme_release=args.pyme_release,pymex_release=args.pymex_release,
                      pyme_build_meson=args.pyme_build_meson
                      )

# TODO: here possibly check a _settings attribute for compatibility with the actual PymeBuild attributes

environment = pbld.env
build_dir = pbld.build_dir

logging.info("Command called as\n")
logging.info(commandline + "\n")

if args.dry_run:
    logging.info("dry run, aborting...")
    import sys
    sys.exit(0)

# check consistency of some of the arg choices
pbld.check_consistency()

# some checks if some of the required packages are available

try:
    # should be available in the base install; otherwise we may need "# conda/pip install packaging"
    from packaging import version
except ImportError:
    raise RuntimeError("need to install module 'packaging' in base environment; e.g. 'conda/pip install packaging'")

try:
    # should be available in the base install; otherwise we may need "# conda/pip install packaging"
    import yaml
except ImportError:
    raise RuntimeError("need to install module 'pyyaml' in base environment; e.g. 'conda/pip install pyyaml'")
    
if pbld.use_git:
    try:
        import git
    except ImportError:
        raise RuntimeError("git could not be imported; install gitpython ( e.g. 'conda/pip install gitpython'); on windows ALSO check for git executable)")


# 1. make test environment
envs = cmds.conda_envs()
import json
logging.info("Found the following envs:")
logging.info(json.dumps(envs,indent=4))

if environment not in envs:
    cc = cmds.conda_create(environment, pbld.pythonver, channels=['conda-forge'])
    logging.info(cc)
    if pbld.strict_conda_forge_channel:
        cc = cmds.run_cmd_in_environment('conda config --env --set channel_priority strict',environment,check=True)
        logging.info(cc)
        cc = cmds.run_cmd_in_environment('conda config --env --add channels conda-forge',environment,check=True)
        logging.info(cc)
        cc = cmds.run_cmd_in_environment('conda config --env --add channels david_baddeley',environment,check=True)
        logging.info(cc)
else:
    print('environment %s already exists' % environment)
    answer = input("Continue?")
    if answer.lower() not in ["y","yes"]:
        print("aborting...")
        import sys
        sys.exit(0)

# just a quick check that we get the expected python version and can invoke it ok
cc = cmds.run_cmd_in_environment('python -V',environment,check=True)
logging.info("got python version info: %s" % cc)

# 2. build/install pyme and dependencies

import platform

prepy3_10 = version.parse(pbld.pythonver) < version.parse("3.10")
postpy3_10 = version.parse(pbld.pythonver) > version.parse("3.10")

if args.matplotlib_numpy_latest:
    matplotlib = 'matplotlib'
elif not prepy3_10: # we are now testing if latest PYME can deal with more recent matplotlib
    matplotlib = 'matplotlib<=3.8'
else:
    matplotlib = 'matplotlib<=3.6'

if args.matplotlib_numpy_latest:
    numpy = 'numpy'
else:
    numpy = 'numpy<2'

if args.setuptools_latest:
    setuptools = 'setuptools'
else:
    setuptools = 'setuptools<=73'

if platform.machine() != 'arm64' and prepy3_10 and pbld.with_pyme_depends:
    packages = Packages['with_pyme_depends']['packages']
    
    result = cmds.conda_install(environment, packages, channels = ['conda-forge','david_baddeley'])
    logging.info(result)
else:
    # install required packages from conda-forge and/or via pip
    # currently we only check for mac and otherwise assume windows; this clearly ignores linux - should be extended when needed
    if  platform.system() == 'Darwin': # now selected for all macs
        package_sets = Packages['no_pyme_depends']['packagelists_mac']['conda']
    else:
        package_sets = Packages['no_pyme_depends']['packagelists_win']['conda']
 
    for packages in package_sets:
        packages_expanded = [pack.replace('$matplotlib$',matplotlib).replace('$numpy$',numpy).replace('$setuptools$',setuptools) for pack in packages]
        result = cmds.conda_install(environment, packages_expanded, channels = ['conda-forge'])
        logging.info(result)

    if  platform.system() == 'Darwin': # now selected for all macs
        # next the main other dependecies
        pip_package_set = Packages['no_pyme_depends']['packagelists_mac']['pip']
    else:
        pip_package_set = Packages['no_pyme_depends']['packagelists_win']['pip']
    # now pip install packages that seem to need a pip install (always subject to checks if really required)
    if len(pip_package_set)>0:
        result = cmds.pip_install(environment, pip_package_set)
        logging.info(result)

######################################
# note that we can get a windows error:
# error: could not create 'build\temp.win-amd64-cpython-310\Release\Users\soeller\src\PYME-test-env\b-py3.10-mamba\python-microscopy-python-310-compat\PYME\Analysis\points\traveling_salesperson':
#        The filename or extension is too long
# silly solution: move PYME-test-env repo close to root of disk and abbreviate build_directory name
#### There must be a better solution!!

if pbld.pyme_release is not None:
    download_mode = 'release'
elif pbld.use_git:
    download_mode = 'git'
else:
    download_mode = 'snapshot'

if pbld.pyme_release is not None:
    download_pyme_release(pbld.pyme_release,build_dir=build_dir,repo=args.pyme_repo,branch=args.pyme_branch)
else:    
    download_pyme(build_dir=build_dir,repo=args.pyme_repo,branch=args.pyme_branch,mode=download_mode)
    
if pbld.with_pyme_build:
    if pbld.pyme_build_meson:
        build_pyme_meson(environment,build_dir=build_dir,repo=args.pyme_repo,branch=args.pyme_branch,release=pbld.pyme_release)
    else:
        build_pyme(environment,build_dir=build_dir,repo=args.pyme_repo,branch=args.pyme_branch,release=pbld.pyme_release)
    # this should fail if our PYME install failed
    result = cmds.run_cmd_in_environment('python -c "import PYME.version; print(PYME.version.version)"',environment,check=True)
    logging.info("Got PYME version %s" % result)

# 3. build/install pyme-extra
if pbld.with_pymex:
    # pyme-extra dependencies are listed in two variables at the top of the file
    #    in Pymex_conda_packages and Pymex_pip_packages
    result = cmds.conda_install(environment, Pymex_conda_packages, channels = ['conda-forge'])
    logging.info(result)

    result = cmds.pip_install(environment, Pymex_pip_packages)
    logging.info(result)

    if pbld.pymex_release is not None:
        download_mode = 'release'
    elif pbld.use_git:
        download_mode = 'git'
    else:
        download_mode = 'snapshot'

    if pbld.pymex_release is not None:
        download_pyme_extra_release(pbld.pymex_release,build_dir=build_dir,repo=args.pymex_repo,branch=args.pymex_branch)
    else:
        download_pyme_extra(build_dir=build_dir,repo=args.pymex_repo,branch=args.pymex_branch,mode=download_mode)
    build_pyme_extra(environment,build_dir=build_dir,repo=args.pymex_repo,branch=args.pymex_branch,release=pbld.pymex_release)
    pyme_extra_install_plugins(environment,build_dir=build_dir,repo=args.pymex_repo,branch=args.pymex_branch,release=pbld.pymex_release)

# 4. some custom recipes for some ease in a testing environment
if pbld.with_recipes:
    output = cmds.run_cmd_in_environment('python install_config_files.py',environment)
    logging.info(output)

# 5. any extra packages although in future this will be preferable via mk_extra_stuff
if pbld.xtra_packages is not None and len(pbld.xtra_packages) > 0:
    result = cmds.conda_install(environment, pbld.xtra_packages, channels = ['conda-forge'])
    logging.info(result)
# potentially here: test for succesfull pyme-extra install
